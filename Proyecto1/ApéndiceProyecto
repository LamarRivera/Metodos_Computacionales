# -*- coding: utf-8 -*-
"""Anexos

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1coN-B1NE8Nh71_w9MD42SCe6gorwZnFb

# Apéndice del primer proyecto

En el presente CoLab se encuentran los códigos ulitizados en la solución del presente proyecto. A modo de introducción se ingresan las bibliotecas necesarias para la ejecución.
"""

import numpy as np
import math
import matplotlib.pyplot as plt
import sympy as sym
import pandas as pd

"""Graficamos el campo electrico segun x"""

#Constantes del modelo

L = 0.2 #H
qc = 0.01 #c
m = L*(qc**2)
C0 = 2*m #F
k = (qc**2)/(C0)
w0 = 1/(np.sqrt(L*C0)) #Hz

#Formula del campo electrico

def Ue(x):
    UE = (k/2)*((x)**2)*((1-x**2)**2)
    return UE

#Variables para graficar
q = np.linspace(-0.02, 0.02, 1000)
x = q/qc
UEE = Ue(x)

#Gráfica de campo eléctrico
plt.plot(x, UEE)
plt.grid
plt.ylim(0,0.5)
plt.xlim(-2, 2)
plt.xlabel("x = q/$q_c$")
plt.ylabel("Electric Field")
plt.title("Electric field magnitude according to charge q")

#Función para hallar raíces

def Uex(x, x0):
    return ((x)**2)*((1-x**2)**2) - ((x0)**2)*((1-x0**2)**2)

UEEX = Uex(x, -1.1)

plt.plot(x, UEEX)
plt.grid()
plt.ylim(-0.1,0.2)
plt.xlim(-1.5, 1.5)
plt.xlabel(r'x = q/$q_c$')
plt.ylabel(r'$U(x) - U(x_0)$')
plt.title("Roots on $0$ of Electric Field with the point $x_0=-1.1$")

UEEX = Uex(x, -1.15)

plt.plot(x, UEEX)
plt.grid()
plt.ylim(0,0.5)
plt.xlabel("x = q/qc")
plt.ylabel(r'$U(x) - U(x_0)$')
plt.title("Roots on $0$ of Electric Field with the point $x_0=-1.15$")
plt.grid
plt.xlim(-2, 2)
plt.ylim(-0.2, 0.4)

UEEX = Uex(x, -1.225)

plt.plot(x, UEEX)
plt.grid()
plt.ylim(0,0.5)
plt.xlabel("x = q/$q_c$")
plt.ylabel(r'$U(x) - U(x_0)$')
plt.title("Roots on $0$ of Electric Field with the point $x_0=-1.225$")
plt.grid
plt.xlim(-2, 2)
plt.ylim(-0.5, 0.3)

"""#Apéndice 1: Programas para encontrar raíces

Para el desarrollo se tiene en cuenta que primero se busca allar todas las raíces con el método de bisección y luego, la primera raíz con el método de Newton-Rapson a modo de comparación por lo que se dejan los programas de cada uno expresos o ejecutados para $x_0 = -1.125$.

"""

x0 = -1.125
U_X0 = (x0**2)*((1-x0**2)**2)

"""## 1.1. Método de bisección

"""

# Definimos la función de forma global
def f(x):
    return (x**2)*((1-x**2)**2) - U_X0

# Definiremos la función para la bisección, en esta deberia estar la función f
# sin embargo ya la definimos anteriormente
# Recordar que en el metodo de bisección tomamos un intervalo [a,b]
# para una función f(x) donde f(a) y f(b) son signos contrarios

def bisección(a,b,tol):
    m1=a
    m=b
    k=0
    if(f(a)*f(b)>0):
        return print("La función no cambia de signo, por tanto este metodo es impreciso para hallar raices")
    while(abs(m1-m)>tol):
        m1=m
        m=(a+b)/2
        if(f(a)*f(m)<0): #La función cambia de signo en el intervalo [a,m]
            b=m
        if(f(m)*f(b)<0): #La función cambia de signo en el intervalo [m,b]
            a=m
        k=k+1;
        
    print ("Pasadas", k, "interaciones se obtiene que", m, "es una buena aproximación")
    
bisección(-1.1, -0.7, 5e-17)

"""## 1.2 Método de Newton-Rapson"""

#Definimos la función de forma global
def NewtonRaphson(x0, tol, n):
    x=sym.symbols('x')
    f= (x**2)*((1-x**2)**2) - U_X0
    df = sym.diff(f)
    f=sym.lambdify(x, f)
    df=sym.lambdify(x, df)
    for k in range(n):
        x1=x0-f(x0)/df(x0)
        if(abs(x1-x0)<tol):
            print('x', k+1, '=', x1, 'es la raiz')
            return
        x0=x1
        print('x', k+1, '=', x1)

NewtonRaphson(-0.9, 0.00001, 100)

"""#Apéndices 2: Programas para el cálculo de integrales por el método de Simpson

Recordando que para este método el error se expresa como $- \frac{h^5}{90}\frac{d^4 f(x)}{dx^4}$ el cálulo de las derivaras se tornan complicadas, por lo que el error se dejará expresado como: $- \frac{h^5}{90}\frac{d^4 U_E(x)}{dx^4}$

"""

#Arreglo para guardar los resultados

#Cantidad de nodos
N = 10
tiempo = np.zeros((5,N,3))
valor_x = np.zeros((5,N,3))

#Valores del dominio a usar
xa = [-1.100,-0.85413,-0.24586,0.24586,0.85413,1.100] #Puntos para xi = − 1.100
xb = [-1.150,-0.66513,-0.48486,0.48486,0.66513,1.1500] #Puntos para xi = − 1.15
xc = [-1.225, 1.225, 0, 0, 0, 0] #Puntos para xi = − 1.225

x = np.array([[xa], [xb], [xc]])
x = np.transpose(x,(1,2,0))

#Valores de x0 para ingresar dentro de la función de campo eléctrico
xinicial = np.array([-1.100,-1.15,-1.1225])

#Función
def funcion(m,k,x0,x):
  c1 = np.sqrt(m/k)
  c2 = (x0**2)*((1-x0**2)**2)
  return c1*(1/np.sqrt(c2-((x**2)*((1-x**2)**2))))

#Método de Simpson

for i in range(5): #valores que va a tomar en cada sub intervalo

  for j in range(N): #para la sub partición de N=10

    #Paso intermedio para el método h = (b - a) / 2N
    h = np.squeeze( ( x[:,i+1,:] - x[:,i,:]  ) / (2*N) )

    #Valores inicial para cada sub partición sin la modificación por indeterminación
    x0 = x[:,i,:] + ( (2*j) * h )

    if j == 0:
      #Corrimiento por singularidad en el primer valor del intervalo
      x0 = x[:,i,:] + 0.001

    valor_x[i,j,:] = x0 #Guardado de variable para facilidad de copia en otro método
    
    #Valores intermedios para cada sub partición
    xint = x[:,i,:] + ( ( 2*j + 1) * h)

    #valores finales para cada sub partición
    x1 = x[:,i,:] + ( (2*j + 2) * h)

    if j == N-1:
      #Corrimiento por singularidad en el primer valor del intervalo
      x1 = x[:,i,:] + ( (2*j + 2) * h) - 0.001

    #Valores de la función
    fx0 = funcion(m,k,xinicial,x0)       # evaluación de la función en el punto x0
    fxint = funcion(m,k,xinicial,xint)   # evaluación de la función en el punto intermedio
    fx1 = funcion(m,k,xinicial,x1)       # evaluación de la función en el punto final

    #Integral
    tiempo[i,j,:] = (np.abs(h) / 3) * (fx0 + 4*fxint + fx1)

plt.plot(valor_x[0,:,0],tiempo[0,:,0],"ob")
plt.grid()
plt.xlabel("x = q/$q_c$ [C]")
plt.ylabel("Time [s]")

"""#Anexo 3: Interpolación de Lagrange"""

x=sym.Symbol("x")

def polinomioL(xi,fi):
  polinomio=0
  for i in range(len(xi)):
    numerador=1
    denominador=1
    for j in range(len(xi)):
      if j!=i:
        numerador*=(x-xi[j])
        denominador*=(xi[i]-xi[j])
    terminoL=numerador/denominador
    polinomio+=terminoL*fi[i]
  return polinomio

def valores(xi,fi):
  polinomio=polinomioL(xi,fi)
  poli_simpli=polinomio.expand()
  px=sym.lambdify(x,poli_simpli)
  muestras=100
  a,b=min(xi),max(xi)
  pxi=np.linspace(a,b,muestras)
  pfi=px(pxi)
  return pxi,pfi,polinomio,poli_simpli

def grafica(xi,fi,pxi,pfi):
  plt.subplots(figsize=(15,8))
  plt.plot(xi,fi,"o",label="Puntos")
  plt.plot(pxi,pfi,label="Polinomio")
  plt.legend()
  plt.grid(1)
  plt.xlabel("xi")
  plt.ylabel("fi")
  plt.title("Interpolación de Lagrange")

"""##Interpolación para $X_0 = -1.000$ """

# Creamos las listas de valores xi y ti para los puntos usarán para la 
# interpolación, tomando los valores de la intgral de la primera raiz
xi = valor_x[0,:,0]
ti = tiempo[0,:,0]

#Llamado de nuestra funcion valores (resultados de la interpolación)
pxi,pti,polinomio,poli_simpli=valores(xi,ti)

polinomio

poli_simpli

grafica(xi,ti,pxi,pti)

"""##Interpolación para $X_0 = -1.125$ 


"""

xi = valor_x[0,:,1]
ti = tiempo[0,:,1]

#Llamado de nuestra funcion valores (resultados de la interpolación)
pxi,pti,polinomio,poli_simpli=valores(xi,ti)

poli_simpli

grafica(xi,ti,pxi,pti)

"""##Interpolación para $X_0 = -1.150$ """

#Cantidad de nodos
N = 10
tiempo = [0,0,0,0,0,0,0,0,0,0]
valor_x = [0,0,0,0,0,0,0,0,0,0]

#Valores del dominio a usar
x = [-1.225, 1.225]

#Método de Simpson
for j in range(N): #para la sub partición de N=10
  #Paso intermedio para el método h = (b - a) / 2N
  h = np.squeeze( ( x[1] - x[0]  ) / (2*N) )

  #Valores inicial para cada sub partición sin la modificación por indeterminación
  x0 = x[0] + ( (2*j) * h )

  if j == 0:
    #Corrimiento por singularidad en el primer valor del intervalo
    x0 = x[0] + 0.001

  valor_x[j] = x0 #Guardado de variable para facilidad de copia en otro método
    
  #Valores intermedios para cada sub partición
  xint = x[0] + ( ( 2*j + 1) * h)

  #valores finales para cada sub partición
  x1 = x[0] + ( (2*j + 2) * h)

  if j == N-1:
    #Corrimiento por singularidad en el primer valor del intervalo
    x1 = x[0] + ( (2*j + 2) * h) - 0.001

  #Valores de la función
  fx0 = funcion(m,k,x[0],x0)       # evaluación de la función en el punto x0
  fxint = funcion(m,k,x[0],xint)   # evaluación de la función en el punto intermedio
  fx1 = funcion(m,k,x[0],x1)       # evaluación de la función en el punto final

  #Integral
  tiempo[j] = (np.abs(h) / 3) * (fx0 + 4*fxint + fx1)

xi = valor_x
ti = tiempo

#Llamado de nuestra funcion valores (resultados de la interpolación)
pxi,pti,polinomio,poli_simpli=valores(xi,ti)

poli_simpli

grafica(xi,ti,pxi,pti)

"""# Apéndice 4: TABLA DE PARAMETRIZACIÓN"""

#Arreglo para guardar los resultados
#Cantidad de nodos
N = 100
tiempo = np.zeros((5,N,3))
valor_x = np.zeros((5,N,3))

#Valores del dominio a usar
xa = [-1.100,-0.85413,-0.24586,0.24586,0.85413,1.100] #Puntos para xi = − 1.100
xb = [-1.150,-0.66513,-0.48486,0.48486,0.66513,1.1500] #Puntos para xi = − 1.15
xc = [-1.225, 1.225, 0, 0, 0, 0] #Puntos para xi = − 1.225

x = np.array([[xa], [xb], [xc]])
x = np.transpose(x,(1,2,0))

#Valores de x0 para ingresar dentro de la función de campo eléctrico
xinicial = np.array([-1.100,-1.15,-1.225])

#Constantes de la función:
m = 2e-05
k = 2.5
c1 = np.sqrt(m/k)

#Función
def funcion(c1,x0,x):
  c2 = (x0**2)*((1-x0**2)**2)
  return c1*(1/np.sqrt(c2-((x**2)*((1-x**2)**2))))



#Método de Simpson

for i in range(5): #valores que va a tomar en cada sub intervalo

  for k in range(N): #para la sub partición de N=10

    #Paso intermedio para el método h = (b - a) / 2N
    h = np.squeeze( ( x[:,i+1,:] - x[:,i,:]  ) / (2*N) )

    #Valores inicial para cada sub partición sin la modificación por indeterminación
    x0 = x[:,i,:] + ( (2*k) * h )

    if k == 0:
      #Corrimiento por singularidad en el primer valor del intervalo
      x0 = x[:,i,:] + 0.001

    valor_x[i,k,:] = x0 #Guardado de variable para facilidad de copia en otro método
    
    #Valores intermedios para cada sub partición
    xint = x[:,i,:] + ( ( 2*k + 1) * h)

    #valores finales para cada sub partición
    x1 = x[:,i,:] + ( (2*k + 2) * h)

    if k == N-1:
      #Corrimiento por singularidad en el primer valor del intervalo
      x1 = x[:,i,:] + ( (2*k + 2) * h) - 0.001

    #Valores de la función
    fx0 = funcion(c1,xinicial,x0)       # evaluación de la función en el punto x0
    fxint = funcion(c1,xinicial,xint)   # evaluación de la función en el punto intermedio
    fx1 = funcion(c1,xinicial,x1)       # evaluación de la función en el punto final

    #Integral
    tiempo[i,k,:] = (np.abs(h) / 3) * (fx0 + 4*fxint + fx1)


plt.plot(valor_x[0,:,0],tiempo[0,:,0],"o",label="Puntos")

L = 0.2 
qc=0.01
m = L*(qc**2)
C0 = 2*m
k = (qc**2)/C0
U_eex = (k/2)*(valor_x[0,:,0]**2)*(1-valor_x[0,:,0]**2)**2
x0 = -1.1
E_0 = (k/2)*(x0**2)*(1-x0**2)**2
Vt = np.sqrt((2*(E_0 - U_eex))/m)
Et = (m*(Vt**2))/2 + U_eex

lista_datos=[tiempo[0,:,0], valor_x[0,:,0], Vt, U_eex, Et]

df_datos = pd.DataFrame(lista_datos)
df_datos1=df_datos.transpose()
df_datos1.columns = ['t', 'x', 'V(t)', 'U_e(t)', 'E(t)']
df_datos1.to_excel('data_datos1.xlsx')

plt.plot(tiempo[0,:,0],valor_x[0,:,0],"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('$x = q/qc$')
plt.title("Time vs Electric Charge")

plt.plot(tiempo[0,:,0],Vt,"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('V$[A]$')
plt.title("Time vs Electric Current")

plt.plot(valor_x[0,:,0],Vt,"o",label="Puntos")
plt.grid()
plt.xlabel('$x = q/qc$')
plt.ylabel('V$[A]$')
plt.title("Electric Charge vs Electric Current")

plt.plot(tiempo[0,:,0],Et,"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('E$[J]$')
plt.title("Time vs Total Energy")

L = 0.2 
qc=0.01
m = L*(qc**2)
C0 = 2*m
k = (qc**2)/C0
U_eex = (k/2)*(valor_x[0,:,1]**2)*(1-valor_x[0,:,1]**2)**2
x0 = -1.15
E_0 = (k/2)*(x0**2)*(1-x0**2)**2
Vt = np.sqrt((2*(E_0 - U_eex))/m)
Et = (m*(Vt**2))/2 + U_eex

lista_datos=[tiempo[0,:,1], valor_x[0,:,1], Vt, U_eex, Et]

df_datos = pd.DataFrame(lista_datos)
df_datos1=df_datos.transpose()
df_datos1.columns = ['t', 'x', 'V(t)', 'U_e(t)', 'E(t)']
df_datos1.to_excel('data_datos2.xlsx')

plt.plot(tiempo[0,:,1],valor_x[0,:,1],"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('$x = q/qc$')
plt.title("Time vs Electric Charge")

plt.plot(tiempo[0,:,1],Vt,"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('V$[A]$')
plt.title("Time vs Electric Current")

plt.plot(valor_x[0,:,1],Vt,"o",label="Puntos")
plt.grid()
plt.xlabel('$x = q/qc$')
plt.ylabel('V$[A]$')
plt.title("Electric Charge vs Electric Current")

plt.plot(tiempo[0,:,1],Et,"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('E$[J]$')
plt.title("Time vs Total Energy")

L = 0.2 
qc=0.01
m = L*(qc**2)
C0 = 2*m
k = (qc**2)/C0
U_eex = (k/2)*(valor_x[0,:,2]**2)*(1-valor_x[0,:,2]**2)**2
x0 = -1.225
E_0 = (k/2)*(x0**2)*(1-x0**2)**2
Vt = np.sqrt((2*(E_0 - U_eex))/m)
Et = (m*(Vt**2))/2 + U_eex

lista_datos=[tiempo[0,:,2], valor_x[0,:,2], Vt, U_eex, Et]

df_datos = pd.DataFrame(lista_datos)
df_datos1=df_datos.transpose()
df_datos1.columns = ['t', 'x', 'V(t)', 'U_e(t)', 'E(t)']
df_datos1.to_excel('data_datos3.xlsx')

plt.plot(tiempo[0,:,2],valor_x[0,:,2],"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('$x = q/qc$')
plt.title("Time vs Electric Charge")

plt.plot(tiempo[0,:,2],Vt,"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('V$[A]$')
plt.title("Time vs Electric Current")

plt.plot(valor_x[0,:,2],Vt,"o",label="Puntos")
plt.grid()
plt.xlabel('$x = q/qc$')
plt.ylabel('V$[A]$')
plt.title("Electric Charge vs Electric Current")

plt.plot(tiempo[0,:,2],Et,"o",label="Puntos")
plt.grid()
plt.xlabel('Time$[s]$')
plt.ylabel('E$[J]$')
plt.title("Time vs Total Energy")

